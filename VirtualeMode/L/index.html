<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Newton Threads — Gravité Gauze</title>
<style>
  :root{ --bg:#000; --fg:#7F7F7F; --edge:26.5px; }
  html,body{
    height:100%; margin:0; background:var(--bg);
    color:var(--fg); font-family:Futura, "Helvetica Neue", Arial, sans-serif;
  }
  /* 画面中央に 3:2 の額縁（角丸） */
  .frame{
    width:min(96vw, 144vh);
    aspect-ratio:3/2;
    position:relative;
    border-radius:var(--edge);
    overflow:hidden;
    background:#000;
    outline:1px solid rgba(127,127,127,0.15);
    box-shadow:0 0 0 1px rgba(127,127,127,0.08) inset;
    margin:auto; top:0; bottom:0;
  }
  canvas{ position:absolute; inset:0; display:block; }
  .hud{
    position:absolute; left:10px; bottom:8px; font-size:12px; letter-spacing:.02em;
    background:rgba(0,0,0,.35); padding:6px 8px; border-radius:10px;
    -webkit-backdrop-filter: blur(2px); backdrop-filter: blur(2px);
  }
  .hud b{ color:#7f7f7f; font-weight:500; }
  .tip{ position:absolute; right:10px; bottom:8px; font-size:11px; opacity:.7 }
</style>
</head>
<body>
  <div class="frame">
    <canvas id="cv"></canvas>
    <div class="hud" id="hud"></div>
    <div class="tip">drag:星 / <b>Shift+wheel</b>:質量 / click:Newton</div>
  </div>

<script>
(() => {
  // --- 基本スケール（ワールド座標は [-1.5..1.5]×[-1..1] の3:2） ---
  const G = 1.0; // 定数は1で正規化
  const world = { xMin:-1.5, xMax: 1.5, yMin:-1.0, yMax: 1.0 };

  // 初期の質点（左右対称）
  const masses = [
    { x:-0.5, y:0.0, m:1.0 },
    { x: 0.5, y:0.0, m:1.0 }
  ];

  const frame = document.querySelector('.frame');
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  // 描画用フラグ
  let needsFieldRedraw = true; // ポテンシャル陰影を描き直すか
  let dragging = { idx:-1, dx:0, dy:0 };
  let paths = []; // ニュートン法の軌跡（配列の配列）

  function resize(){
    const w = frame.clientWidth|0, h = frame.clientHeight|0;
    canvas.width = (w * dpr)|0; canvas.height = (h * dpr)|0;
    canvas.style.width = w+"px"; canvas.style.height = h+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    needsFieldRedraw = true;
    draw();
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // --- 座標変換 ---
  function toScreenX(x){
    const w = frame.clientWidth;
    return (x - world.xMin) / (world.xMax - world.xMin) * w;
  }
  function toScreenY(y){
    const h = frame.clientHeight;
    return (1 - (y - world.yMin) / (world.yMax - world.yMin)) * h;
  }
  function toWorld(sx, sy){
    const w = frame.clientWidth, h = frame.clientHeight;
    const x = world.xMin + (sx / w) * (world.xMax - world.xMin);
    const y = world.yMin + (1 - sy / h) * (world.yMax - world.yMin);
    return {x,y};
  }

  // --- 力（ベクトル） F(x,y) = Σ -G m (r)/|r|^3 ---
  function force(p){
    let fx = 0, fy = 0;
    for(const s of masses){
      const dx = p.x - s.x, dy = p.y - s.y;
      const r2 = dx*dx + dy*dy;
      const r = Math.sqrt(r2);
      // 小さすぎると発散するので避ける
      const rr3 = Math.max(r2*r, 1e-9);
      const c = -G * s.m / rr3;
      fx += c * dx;
      fy += c * dy;
    }
    return {x:fx, y:fy};
  }

  // --- 2×2 ヤコビアン（有限差分の中心差分） ---
  function jacobian(p, eps=1e-4){
    const fpx = force({x:p.x+eps, y:p.y});
    const fmx = force({x:p.x-eps, y:p.y});
    const fpy = force({x:p.x, y:p.y+eps});
    const fmy = force({x:p.x, y:p.y-eps});
    return [
      [ (fpx.x - fmx.x)/(2*eps), (fpy.x - fmy.x)/(2*eps) ],
      [ (fpx.y - fmx.y)/(2*eps), (fpy.y - fmy.y)/(2*eps) ]
    ];
  }

  // --- 2×2 連立を解く（J * d = F を解き d = J^{-1}F）---
  function solve2(J, F){
    const a=J[0][0], b=J[0][1], c=J[1][0], d=J[1][1];
    const det = a*d - b*c;
    if(Math.abs(det) < 1e-12) return null;
    const inv = [[ d/det, -b/det], [-c/det, a/det]];
    return { x: inv[0][0]*F.x + inv[0][1]*F.y, y: inv[1][0]*F.x + inv[1][1]*F.y };
  }

  // --- ニュートン法（ベクトル版） ---
  function newtonFrom(p0, maxIter=20, tol=1e-6){
    const path = [{x:p0.x, y:p0.y}];
    let p = {x:p0.x, y:p0.y};
    for(let k=0;k<maxIter;k++){
      const F = force(p);
      const nF = Math.hypot(F.x, F.y);
      if(nF < tol) break;
      const J = jacobian(p);
      const d = solve2(J, F);
      if(!d) break; // 特異
      // p_{n+1} = p_n - d
      p = { x: p.x - d.x, y: p.y - d.y };
      if(!isFinite(p.x) || !isFinite(p.y)) break;
      path.push(p);
    }
    return path;
  }

  // --- ポテンシャル陰影（粗格子→拡大描画） ---
  let fieldCanvas = document.createElement('canvas');
  let fieldDirty = true;
  function drawField(){
    if(!needsFieldRedraw) return;
    needsFieldRedraw = false;

    const W = 96, H = 64; // とても粗い：軽量
    fieldCanvas.width = W; fieldCanvas.height = H;
    const g = fieldCanvas.getContext('2d');
    const img = g.createImageData(W, H);

    // Φの最小/最大を求めつつ計算
    let min=Infinity, max=-Infinity;
    const phi = new Float32Array(W*H);

    for(let j=0;j<H;j++){
      for(let i=0;i<W;i++){
        const x = world.xMin + (i+0.5)/W * (world.xMax - world.xMin);
        const y = world.yMin + (1 - (j+0.5)/H) * (world.yMax - world.yMin);
        let phi_ij = 0;
        for(const s of masses){
          const dx = x - s.x, dy = y - s.y;
          const r = Math.hypot(dx, dy);
          phi_ij += -G * s.m / Math.max(r, 1e-6);
        }
        phi[j*W + i] = phi_ij;
        if(phi_ij < min) min = phi_ij;
        if(phi_ij > max) max = phi_ij;
      }
    }

    const span = Math.max(max - min, 1e-9);
    for(let j=0;j<H;j++){
      for(let i=0;i<W;i++){
        const k = j*W + i;
        let t = (phi[k] - min) / span;          // [0,1]
        t = Math.pow(t, 0.65);                  // γ補正
        const alpha = Math.min(255, Math.floor(255 * 0.22 * t));
        const idx = k*4;
        img.data[idx+0] = 255; // 白ベース（薄い紗）
        img.data[idx+1] = 255;
        img.data[idx+2] = 255;
        img.data[idx+3] = alpha;
      }
    }
    g.putImageData(img, 0, 0);
  }

  function draw(){
    const w = frame.clientWidth, h = frame.clientHeight;
    ctx.clearRect(0,0,w,h);

    // フィールド（ガーゼ）
    drawField();
    ctx.imageSmoothingEnabled = true;
    ctx.globalAlpha = 1.0;
    ctx.drawImage(fieldCanvas, 0, 0, w, h);

    // ニュートンの糸（軌跡）
    ctx.lineWidth = 1;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    for(const path of paths){
      ctx.beginPath();
      for(let i=0;i<path.length;i++){
        const p = path[i];
        const sx = toScreenX(p.x), sy = toScreenY(p.y);
        if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.45)';
      ctx.stroke();

      // 終点の“点珠”
      const last = path[path.length-1];
      const lx = toScreenX(last.x), ly = toScreenY(last.y);
      ctx.beginPath();
      ctx.arc(lx, ly, 2.2, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fill();
    }

    // 星（質点）
    for(let i=0;i<masses.length;i++){
      const s = masses[i];
      const sx = toScreenX(s.x), sy = toScreenY(s.y);
      const r = 7 + Math.min(10, s.m*2); // 質量で微妙に大きさ
      ctx.beginPath();
      ctx.arc(sx, sy, r, 0, Math.PI*2);
      ctx.fillStyle = 'white';
      ctx.globalAlpha = 0.9; ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.beginPath();
      ctx.arc(sx, sy, r+2.5, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(127,127,127,0.35)';
      ctx.stroke();
    }

    // HUD
    hud.innerHTML = masses.map((s,i)=>`★${i+1} (x:${s.x.toFixed(2)}, y:${s.y.toFixed(2)}, m:${s.m.toFixed(2)})`).join(' &nbsp; ');
  }

  // --- マウス/ポインタ操作 ---
  function findMassAt(sx, sy){
    for(let i=masses.length-1; i>=0; i--){
      const s = masses[i];
      const dx = sx - toScreenX(s.x), dy = sy - toScreenY(s.y);
      if(dx*dx + dy*dy < 16*16) return i;
    }
    return -1;
  }

  canvas.addEventListener('pointerdown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const idx = findMassAt(sx, sy);
    if(idx>=0){
      dragging.idx = idx;
      const s = masses[idx];
      dragging.dx = toScreenX(s.x) - sx;
      dragging.dy = toScreenY(s.y) - sy;
    } else {
      // 質点を掴んでいなければ、ここからニュートン法
      const p0 = toWorld(sx, sy);
      const path = newtonFrom(p0, 24, 1e-6);
      paths.push(path);
      draw();
    }
  });

  window.addEventListener('pointermove', (e)=>{
    if(dragging.idx<0) return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left + dragging.dx;
    const sy = e.clientY - rect.top  + dragging.dy;
    const p = toWorld(sx, sy);
    masses[dragging.idx].x = Math.max(world.xMin+0.01, Math.min(world.xMax-0.01, p.x));
    masses[dragging.idx].y = Math.max(world.yMin+0.01, Math.min(world.yMax-0.01, p.y));
    needsFieldRedraw = true;
    draw();
  });

  window.addEventListener('pointerup', ()=>{ dragging.idx=-1; });

  // 質量変更（Shift+ホイール）
  canvas.addEventListener('wheel', (e)=>{
    if(!e.shiftKey) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const idx = findMassAt(sx, sy);
    if(idx<0) return;
    const s = masses[idx];
    const delta = -Math.sign(e.deltaY) * 0.1;
    s.m = Math.max(0.1, Math.min(8, s.m + delta));
    needsFieldRedraw = true;
    draw();
  }, {passive:false});

  // C キーで軌跡クリア
  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='c'){ paths = []; draw(); }
  });

  // 初回描画
  draw();
})();
</script>
</body>
</html>
