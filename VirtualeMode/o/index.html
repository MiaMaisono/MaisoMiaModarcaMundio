<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>#o – ϻiapol𝐯o</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; }
  /* 背景の⭐︎を描くキャンバス */
  #sky {
    position: fixed; inset: 0; display: block; background: #000;
    z-index: 0; pointer-events: none;
  }
  /* 中央リンク（そのまま） */
  .center {
    position: relative; z-index: 1; height: 100%;
    display: grid; place-items: center;
  }
  .links { display: flex; gap: 4em; }
  .links a {
    text-decoration: none; color: #7F7F7F;
    font-size: 3.14159265359em; font-style: italic; letter-spacing: 0.01em;
    -webkit-tap-highlight-color: rgba(255,255,255,0.1);
  }
  .links a.femme { font-family: Futura, sans-serif; }
  .links a.homme { font-family: Helvetica, Arial, sans-serif; }
  .links a:hover { text-decoration: underline; }
  .links a:focus-visible { outline: 2px dashed #7F7F7F; outline-offset: 6px; }
</style>
</head>
<body>
  <canvas id="sky" aria-hidden="true"></canvas>

  <div class="center">
    <nav class="links" aria-label="primary">
      <a class="femme" href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/2" target="_blank" rel="noopener">Femme</a>
      <a class="homme" href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/1" target="_blank" rel="noopener">Homme</a>
    </nav>
  </div>

<script>
/* ====== 画像→⭐︎ 座標抽出設定 ====== */
/* GitHubのRaw画像URLを入れてください */
const SOURCE_IMAGE = 'https://raw.githubusercontent.com/USER/REPO/BRANCH/path/sky-610-mecca-1728.png';
const IMG_SIZE = 1728;          // スクショの一辺（px）
const THRESH = 235;             // 白判定しきい値 (R,G,B>=235)
const STEP = 2;                 // 走査間隔（2〜3が軽量）
const MIN_BLOB = 1;             // 小さすぎる塊の除外
const MAX_BLOB = 100;           // 大きすぎる塊の除外（星雲などを弾く）
const STAR_CHAR = '⭐︎';         // 背景はこの記号で再現
const STAR_COLOR = '#FFF';      // 白のみ

const canvas = document.getElementById('sky');
const ctx = canvas.getContext('2d');
let starNorms = [];   // {x:0..1, y:0..1, t:0..1(大きさ比)}

function fit() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  drawStars();
}
window.addEventListener('resize', fit, { passive:true });

(async function start(){
  fit();
  await extractStars();
  drawStars();
})().catch(err => console.error('star build error:', err));

async function extractStars(){
  const img = await loadImage(SOURCE_IMAGE);

  const off = document.createElement('canvas');
  off.width = IMG_SIZE; off.height = IMG_SIZE;
  const ox = off.getContext('2d');
  ox.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);

  const cx = IMG_SIZE/2, cy = IMG_SIZE/2, R = IMG_SIZE/2;
  const src = ox.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
  const mask = new Uint8Array(IMG_SIZE * IMG_SIZE);

  // 円の内側だけ白い点を拾う
  for (let y=0; y<IMG_SIZE; y+=STEP){
    const dy = y - cy, dy2 = dy*dy;
    for (let x=0; x<IMG_SIZE; x+=STEP){
      const dx = x - cx;
      if (dx*dx + dy2 > R*R) continue;
      const i = (y*IMG_SIZE + x) * 4;
      const r = src.data[i], g = src.data[i+1], b = src.data[i+2];
      if (r>=THRESH && g>=THRESH && b>=THRESH) mask[y*IMG_SIZE + x] = 1;
    }
  }

  // 連結成分で重心と面積（=明るさの代用）を取る
  const visited = new Uint8Array(mask.length);
  const qx = [], qy = [];
  const stars = [];

  for (let y0=0; y0<IMG_SIZE; y0+=STEP){
    for (let x0=0; x0<IMG_SIZE; x0+=STEP){
      const idx0 = y0*IMG_SIZE + x0;
      if (!mask[idx0] || visited[idx0]) continue;

      let sumX=0, sumY=0, count=0;
      let head=0, tail=0;
      qx[tail]=x0; qy[tail]=y0; tail++;
      visited[idx0]=1;

      while (head<tail){
        const x=qx[head], y=qy[head]; head++;
        const idx=y*IMG_SIZE + x;
        sumX+=x; sumY+=y; count++;

        neigh(x+STEP, y); neigh(x-STEP, y);
        neigh(x, y+STEP); neigh(x, y-STEP);

        function neigh(nx, ny){
          if (nx<0||ny<0||nx>=IMG_SIZE||ny>=IMG_SIZE) return;
          const nidx = ny*IMG_SIZE + nx;
          if (!mask[nidx] || visited[nidx]) return;
          visited[nidx]=1; qx[tail]=nx; qy[tail]=ny; tail++;
        }
      }

      if (count>=MIN_BLOB && count<=MAX_BLOB){
        const gx = sumX/count, gy = sumY/count;
        const dx = gx - cx, dy = gy - cy;
        if (dx*dx + dy*dy <= (R-2)*(R-2)) {
          stars.push({ x: gx/IMG_SIZE, y: gy/IMG_SIZE, w: count });
        }
      }
    }
  }

  // 面積→サイズ比 0..1
  const wMin = Math.min(...stars.map(s=>s.w));
  const wMax = Math.max(...stars.map(s=>s.w));
  const span = Math.max(1, wMax - wMin);
  starNorms = stars.map(s => ({ x:s.x, y:s.y, t:(s.w - wMin)/span }));
  console.log(`Detected stars: ${starNorms.length}`);
}

function drawStars(){
  if (!starNorms.length) return;
  const w = canvas.width, h = canvas.height;
  const size = Math.min(w, h);
  const offX = (w - size)/2, offY = (h - size)/2;

  ctx.clearRect(0,0,w,h);
  // 円形クリップ
  ctx.save();
  ctx.beginPath();
  ctx.arc(w/2, h/2, size/2, 0, Math.PI*2);
  ctx.clip();

  // ⭐︎サイズ：最小6px〜最大14px（画面に比例）
  const pxMin = 6 * (size/IMG_SIZE);
  const pxMax = 14 * (size/IMG_SIZE);

  ctx.fillStyle = STAR_COLOR;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i=0; i<starNorms.length; i++){
    const s = starNorms[i];
    const fs = pxMin + (pxMax - pxMin) * Math.pow(s.t, 0.65);
    ctx.font = `${fs}px serif`;
    ctx.fillText(STAR_CHAR, offX + s.x*size, offY + s.y*size);
  }
  ctx.restore();
}

function loadImage(src){
  return new Promise((res, rej)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous'; // GitHub Raw等から読み込むため
    img.onload = ()=>res(img);
    img.onerror = rej;
    img.src = src;
  });
}
</script>
</body>
</html>