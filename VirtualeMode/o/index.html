<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>。</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --fg: #7F7F7F; /* Græy */
    --bg: #000000; /* 中央円の黒 */
  }

  html, body {
    height: 100%;
    margin: 0;
  }

  /* 余白部分：毎回 JS からランダム色を設定する前提 */
  body {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #000000; /* 初期値（JSで上書き） */
  }

  /* 中央の真円（画面短辺にフィット） */
  .circle {
    position: relative;
    width: calc(min(100vw, 100vh) - 0px); /* ほぼ画面いっぱいの円 */
    aspect-ratio: 1 / 1;
    max-width: 100vw;
    max-height: 100vh;
    border-radius: 50%;
    overflow: hidden;
    background: var(--bg);   /* 内側は完全黒 */
  }

  /* 星空キャンバス（円の内側） */
  #sky {
    position: absolute;
    inset: 0;
    display: block;
    background: #000;
    z-index: 0;
    pointer-events: none;
  }

  /* 中央リンク */
  .center {
    position: relative;
    z-index: 1;
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
  }

  .links {
    display: flex;
    gap: 4em;
  }

  .links a {
    text-decoration: none;
    color: #7F7F7F; /* Græy */
    font-size: 3.14159265359em;
    font-style: italic;
    letter-spacing: 0.01em;
    -webkit-tap-highlight-color: rgba(255,255,255,0.1);
  }

  .links a.femme { font-family: Futura, sans-serif; }
  .links a.homme { font-family: Helvetica, Arial, sans-serif; }

  .links a:hover { text-decoration: underline; }

  .links a:focus-visible {
    outline: 2px dashed #7F7F7F;
    outline-offset: 6px;
  }
</style>
</head>
<body>
  <div class="circle">
    <canvas id="sky" aria-hidden="true"></canvas>

    <div class="center">
      <nav class="links" aria-label="primary">
        <a class="femme"
           href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/2"
           target="_blank" rel="noopener">Femme</a>
        <a class="homme"
           href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/1"
           target="_blank" rel="noopener">Homme</a>
      </nav>
    </div>
  </div>

<script>
/* =========================
   背景色を #000000〜#FFFFFF の中でランダムに
   ========================= */
(function setRandomBackground() {
  try {
    const n = Math.floor(Math.random() * 0x1000000); // 0〜16777215
    const hex = n.toString(16).padStart(6, '0');
    document.body.style.backgroundColor = '#' + hex;
  } catch (e) {
    // 失敗時は初期値の黒のまま
  }
})();

/* =========================
   星レイヤー設定（7レイヤー）
   ※ 合計 6236 個、7等星までの比率に準拠
   ========================= */
const STAR_LAYERS = [
  { count: 2,    sizeMul: 1.50 }, // 最も明るい
  { count: 5,    sizeMul: 1.30 },
  { count: 19,   sizeMul: 1.10 },
  { count: 74,   sizeMul: 0.90 },
  { count: 294,  sizeMul: 0.70 },
  { count: 1172, sizeMul: 0.55 },
  { count: 4670, sizeMul: 0.40 }  // 最も暗い
];
const TOTAL_STARS = STAR_LAYERS.reduce((s, l) => s + l.count, 0); // 6236

const STAR_CHAR  = '⭐︎';
const STAR_COLOR = '#FFFFFF';

/* =========================
   キャンバス & レイアウト
   ========================= */
const container = document.querySelector('.circle');
const canvas    = document.getElementById('sky');
const ctx       = canvas.getContext('2d');

let cssW = 0, cssH = 0;
let dpr  = window.devicePixelRatio || 1;

let stars = [];   // { x: -0.5..0.5, y: -0.5..0.5, layer: 0..6 }
let starLayer = null;

function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  cssW = rect.width;
  cssH = rect.height;
  dpr  = window.devicePixelRatio || 1;

  canvas.width  = Math.max(1, Math.floor(cssW * dpr));
  canvas.height = Math.max(1, Math.floor(cssH * dpr));
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  if (!stars.length) {
    initStars();
  }
  buildStarLayer();
}

window.addEventListener('resize', resizeCanvas, { passive: true });

/* =========================
   星データ生成（7レイヤー）
   ========================= */
function initStars() {
  stars = [];
  STAR_LAYERS.forEach((layer, layerIndex) => {
    for (let i = 0; i < layer.count; i++) {
      // 円内一様分布（半径 0.5 の円）
      const r = Math.sqrt(Math.random()) * 0.5;
      const t = Math.random() * Math.PI * 2;
      const sx = r * Math.cos(t);
      const sy = r * Math.sin(t);
      stars.push({
        x: sx,    // -0.5 .. +0.5
        y: sy,    // -0.5 .. +0.5
        layer: layerIndex
      });
    }
  });
}

/* =========================
   静止星レイヤー描画
   ========================= */
function buildStarLayer() {
  if (!stars.length || !cssW || !cssH) return;

  const size = Math.min(cssW, cssH);

  starLayer = document.createElement('canvas');
  starLayer.width  = size;
  starLayer.height = size;
  const ox = starLayer.getContext('2d');

  // 背景黒
  ox.fillStyle = '#000000';
  ox.fillRect(0, 0, size, size);

  ox.fillStyle    = STAR_COLOR;
  ox.textAlign    = 'center';
  ox.textBaseline = 'middle';

  // ベースサイズ（画面サイズに比例）
  const base = Math.max(2, size / 180); // 調整パラメータ

  for (const s of stars) {
    const layer = STAR_LAYERS[s.layer];
    const px = (0.5 + s.x) * size;
    const py = (0.5 + s.y) * size;

    const fontSize = base * layer.sizeMul;
    ox.font = `${fontSize}px serif`;
    ox.fillText(STAR_CHAR, px, py);
  }
}

/* =========================
   流れ星ロジック
   - 初回訪問：必ず1本
   - 2回目以降：挑戦回数に応じて指数関数的に確率UP
   ========================= */
const METEOR_KEY = 'vm_o_meteor_attempts';
const meteors = [];

function registerVisitAndMaybeSpawnMeteor() {
  let attempts = 0;
  try {
    const raw = localStorage.getItem(METEOR_KEY);
    attempts = raw ? (parseInt(raw, 10) || 0) : 0;
  } catch (e) {
    attempts = 0;
  }
  attempts++;
  try {
    localStorage.setItem(METEOR_KEY, String(attempts));
  } catch (e) {
    // プライベートモードなどでは無視
  }

  if (attempts === 1) {
    // 初回は必ず1本
    spawnMeteor();
  } else {
    // P = 1 - exp(-k * attempts) で指数的に上昇
    const k = 0.12; // 調整可能
    const p = 1 - Math.exp(-k * attempts);
    if (Math.random() < p) {
      spawnMeteor();
    }
  }
}

function spawnMeteor() {
  if (!cssW || !cssH) return;

  const size = Math.min(cssW, cssH);

  // 画面内ランダム位置からランダムな方向へ
  const angle = Math.random() * Math.PI * 2;
  const length = (0.25 + Math.random() * 0.35) * size;
  const speed  = length / (0.7 + Math.random() * 0.6); // px/s
  const life   = length / speed;

  const x0 = Math.random() * cssW;
  const y0 = Math.random() * cssH;
  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;

  meteors.push({
    x: x0,
    y: y0,
    vx,
    vy,
    life,
    age: 0
  });
}

function updateMeteors(dt) {
  for (let i = meteors.length - 1; i >= 0; i--) {
    const m = meteors[i];
    m.age += dt;
    m.x   += m.vx * dt;
    m.y   += m.vy * dt;

    if (m.age >= m.life ||
        m.x < -50 || m.y < -50 ||
        m.x > cssW + 50 || m.y > cssH + 50) {
      meteors.splice(i, 1);
    }
  }
}

function drawFrame() {
  if (!cssW || !cssH) return;

  // 円＝container は正方形なので、星レイヤーも正方形にフィットさせる
  const size = Math.min(cssW, cssH);
  ctx.clearRect(0, 0, cssW, cssH);

  if (starLayer) {
    // starLayer は size×size なので、左上に貼る
    ctx.drawImage(starLayer, 0, 0, size, size);
  }

  if (!meteors.length) return;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (const m of meteors) {
    const alpha = Math.max(0, 1 - m.age / m.life);
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#7F7F7F';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(m.x - m.vx * 0.07, m.y - m.vy * 0.07);
    ctx.lineTo(m.x, m.y);
    ctx.stroke();
  }
  ctx.restore();
}

/* =========================
   アニメーションループ
   ========================= */
let lastTime = null;
function loop(timestamp) {
  if (lastTime == null) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  updateMeteors(dt);
  drawFrame();

  requestAnimationFrame(loop);
}

/* =========================
   起動
   ========================= */
function start() {
  resizeCanvas();
  registerVisitAndMaybeSpawnMeteor();
  requestAnimationFrame(loop);
}

start();
</script>
</body>
</html>