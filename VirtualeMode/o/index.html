<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>。</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --fg: #7F7F7F; /* Græy */
      --bg: #000000; /* 中央楕円は常に真黒 */
    }

    html, body {
      height: 100%;
      margin: 0;
    }

    /* 余白部分（楕円の外側）は JS で毎回ランダム色にする */
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background-color: #000; /* 初期値。後で上書き */
    }

    /* 画面全体を覆う楕円（正方形の画面なら真円） */
    .circle {
      position: relative;
      width: 100vw;
      height: 100vh;
      border-radius: 50%;   /* ビューポートに内接する楕円 */
      overflow: hidden;
      background: var(--bg); /* 内側は完全黒 */
    }

    /* 星空キャンバス（楕円の内側） */
    #sky {
      position: absolute;
      inset: 0;
      display: block;
      background: #000;
      z-index: 0;
      pointer-events: none;
    }

    /* 中央リンク */
    .center {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
    }

    .links {
      display: flex;
      gap: 4em;
    }

    .links a {
      text-decoration: none;
      color: var(--fg);               /* Græy */
      font-size: 3.14159265359em;
      font-style: italic;
      letter-spacing: 0.01em;
      -webkit-tap-highlight-color: rgba(255,255,255,0.1);
    }

    .links a.femme { font-family: Futura, sans-serif; }
    .links a.homme { font-family: Helvetica, Arial, sans-serif; }

    .links a:hover {
      text-decoration: underline;
    }

    .links a:focus-visible {
      outline: 2px dashed var(--fg);
      outline-offset: 6px;
    }
  </style>
</head>
<body>
  <div class="circle">
    <canvas id="sky" aria-hidden="true"></canvas>

    <div class="center">
      <nav class="links" aria-label="primary">
        <a class="femme"
           href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/2"
           target="_blank" rel="noopener">Femme</a>
        <a class="homme"
           href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/1"
           target="_blank" rel="noopener">Homme</a>
      </nav>
    </div>
  </div>

  <script>
    /* =============================
       1. 余白色を毎回ランダムに
       ============================= */
    (function setRandomBackground() {
      const n = Math.floor(Math.random() * 0x1000000);     // 0〜16,777,215
      const hex = n.toString(16).padStart(6, "0");
      document.body.style.backgroundColor = "#" + hex;
    })();

    /* =============================
       2. 星空と流れ星
       ============================= */

    const STAR_COUNT = 1200;        // 星の数
    const STAR_COLOR = "#FFFFFF";   // 星は真っ白
    const STORAGE_KEY = "mqc_meteor_attempts";

    const circle = document.querySelector(".circle");
    const canvas = document.getElementById("sky");
    const ctx = canvas.getContext("2d");

    let cssW = 0, cssH = 0;
    let dpr  = window.devicePixelRatio || 1;

    let starLayer = null;   // オフスクリーンに描いた静止星
    let meteor = null;      // いま飛んでいる流れ星
    let animId = null;
    let lastTime = 0;

    /* ---- レイアウト ---- */
    function resizeCanvas() {
      const rect = circle.getBoundingClientRect();
      cssW = rect.width;
      cssH = rect.height;
      dpr  = window.devicePixelRatio || 1;

      canvas.width  = Math.max(1, Math.floor(cssW * dpr));
      canvas.height = Math.max(1, Math.floor(cssH * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      buildStarLayer();
      paintStatic();
    }

    window.addEventListener("resize", resizeCanvas, { passive: true });

    /* ---- 星を作る（単純にランダム） ---- */
    function buildStarLayer() {
      if (!cssW || !cssH) return;

      const w = cssW;
      const h = cssH;
      const cx = w / 2;
      const cy = h / 2;
      const rx = w / 2;
      const ry = h / 2;

      starLayer = document.createElement("canvas");
      starLayer.width  = w;
      starLayer.height = h;
      const ox = starLayer.getContext("2d");

      // 背景（楕円内だけ黒）
      ox.fillStyle = "#000000";
      ox.fillRect(0, 0, w, h);

      ox.save();
      ox.beginPath();
      ox.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      ox.clip();

      ox.fillStyle = STAR_COLOR;

      for (let i = 0; i < STAR_COUNT; i++) {
        // 楕円内一様乱数
        let x, y;
        while (true) {
          x = Math.random() * w;
          y = Math.random() * h;
          const dx = (x - cx) / rx;
          const dy = (y - cy) / ry;
          if (dx * dx + dy * dy <= 1) break;
        }
        const r = 0.7 + Math.random() * 1.3;  // ちょっとだけサイズ差
        ox.beginPath();
        ox.arc(x, y, r, 0, Math.PI * 2);
        ox.fill();
      }

      ox.restore();
    }

    function paintStatic() {
      if (!cssW || !cssH || !starLayer) return;
      ctx.clearRect(0, 0, cssW, cssH);
      ctx.drawImage(starLayer, 0, 0, cssW, cssH);
    }

    /* ---- 流れ星 ---- */
    function spawnMeteor() {
      if (!cssW || !cssH) return;

      const w = cssW;
      const h = cssH;
      const size = Math.min(w, h);

      const angle = Math.random() * Math.PI * 2;
      const length = (0.35 + Math.random() * 0.4) * size;
      const duration = 0.8 + Math.random() * 0.6;   // 飛ぶ時間 [秒]
      const speed = length / duration;

      const cx = w / 2;
      const cy = h / 2;
      const rx = w / 2;
      const ry = h / 2;

      // 楕円の中に入るよう、中心付近からスタート
      let x0, y0;
      while (true) {
        x0 = cx + (Math.random() * 0.6 - 0.3) * w;
        y0 = cy + (Math.random() * 0.6 - 0.3) * h;
        const dx = (x0 - cx) / rx;
        const dy = (y0 - cy) / ry;
        if (dx * dx + dy * dy <= 1) break;
      }

      meteor = {
        x: x0,
        y: y0,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: duration,
        age: 0
      };

      if (animId == null) {
        lastTime = performance.now();
        animId = requestAnimationFrame(step);
      }
    }

    function step(t) {
      const dt = (t - lastTime) / 1000;
      lastTime = t;

      if (meteor) {
        meteor.age += dt;
        meteor.x += meteor.vx * dt;
        meteor.y += meteor.vy * dt;

        if (meteor.age >= meteor.life) {
          meteor = null;
        }
      }

      paintStatic();

      if (meteor) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const alpha = Math.max(0, 1 - meteor.age / meteor.life);
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 1.4;

        ctx.beginPath();
        ctx.moveTo(
          meteor.x - meteor.vx * 0.10,
          meteor.y - meteor.vy * 0.10
        );
        ctx.lineTo(meteor.x, meteor.y);
        ctx.stroke();
        ctx.restore();

        animId = requestAnimationFrame(step);
      } else {
        // 終了したらアニメーションを止める（省エネ）
        animId = null;
      }
    }

    /* ---- 流れ星の出現確率（試行ごとに指数関数的に上昇） ---- */
    function shouldSpawnMeteorThisVisit() {
      let attempts = Number(localStorage.getItem(STORAGE_KEY) || "0");
      attempts += 1;
      localStorage.setItem(STORAGE_KEY, String(attempts));

      if (attempts === 1) {
        // 初回は必ず流れ星
        return true;
      }

      const base   = 0.0005;  // 初回付近の確率（0.05%）
      const growth = 1.4;     // 乗数。ここを変えると上がり方が変わる
      const maxP   = 0.8;     // 上限 80%

      const p = Math.min(maxP, base * Math.pow(growth, attempts - 1));
      // console.log(`attempt #${attempts}, p=${p}`);
      return Math.random() < p;
    }

    /* ---- 初期化 ---- */
    function init() {
      resizeCanvas();
      if (shouldSpawnMeteorThisVisit()) {
        spawnMeteor();
      } else {
        paintStatic();
      }
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>