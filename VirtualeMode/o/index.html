<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>。</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --fg: #7F7F7F; /* Græy */
    --bg: #000000;
  }

  html, body {
    height: 100%;
    margin: 0;
  }

  /* ===== 背景（円の外側）：黒×Græyのチェック柄 ===== */
          body {
            display: flex;
            align-items: center;
            justify-content: center;
          
            /* ベースは黒 */
            background-color: #000000;
          
            /* 透過チェック柄風（黒 × Græy） */
            background-image:
              linear-gradient(45deg,
                #7F7F7F 25%, transparent 25%,
                transparent 50%, #7F7F7F 50%,
                #7F7F7F 75%, transparent 75%,
                transparent 100%),
              linear-gradient(45deg,
                #7F7F7F 25%, transparent 25%,
                transparent 50%, #7F7F7F 50%,
                #7F7F7F 75%, transparent 75%,
                transparent 100%);
            background-size: 4px 4px;      /* マスの大きさ（もっと細かくしたければ 2px とかに） */
            background-position: 0 0, 2px 2px;
          }

  /* ===== 真円UIコンテナ ===== */
  .circle {
    position: relative;
    /* 画面の短辺から 19px ずつオフセットして最大サイズ */
    width: calc(min(100vw, 100vh) - 38px);
    aspect-ratio: 1 / 1;
    max-width: 100vw;
    max-height: 100vh;
    border-radius: 50%;
    overflow: hidden;
    /* 円のまわりの Græy 枠は不要なので削除 */
    background: var(--bg);   /* 内側は完全黒 */
  }

  /* 星空キャンバス（円の内側） */
  #sky {
    position: absolute;
    inset: 0;
    display: block;
    background: #000;
    z-index: 0;
    pointer-events: none;
  }

  /* 中央リンク（そのまま） */
  .center {
    position: relative;
    z-index: 1;
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
  }

  .links {
    display: flex;
    gap: 4em;
  }

  .links a {
    text-decoration: none;
    color: #7F7F7F;
    font-size: 3.14159265359em;
    font-style: italic;
    letter-spacing: 0.01em;
    -webkit-tap-highlight-color: rgba(255,255,255,0.1);
  }

  .links a.femme { font-family: Futura, sans-serif; }
  .links a.homme { font-family: Helvetica, Arial, sans-serif; }

  .links a:hover { text-decoration: underline; }

  .links a:focus-visible {
    outline: 2px dashed #7F7F7F;
    outline-offset: 6px;
  }
</style>
</head>
<body>
  <div class="circle">
    <canvas id="sky" aria-hidden="true"></canvas>

    <div class="center">
      <nav class="links" aria-label="primary">
        <a class="femme"
           href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/2"
           target="_blank" rel="noopener">Femme</a>
        <a class="homme"
           href="https://opensea.io/item/ethereum/0xd91cd9974a4e19e4d23a4a2d94e2e5dd172eee8d/1"
           target="_blank" rel="noopener">Homme</a>
      </nav>
    </div>
  </div>

<script>
/* ====== 設定：星図画像 & 検出パラメータ ====== */
const SOURCE_IMAGE = 'https://raw.githubusercontent.com/USER/REPO/BRANCH/path/sky-610-mecca-1728.png';

const IMG_SIZE   = 1728;
const THRESH     = 235;
const STEP       = 2;
const MIN_BLOB   = 1;
const MAX_BLOB   = 100;
const STAR_CHAR  = '⭐︎';
const STAR_COLOR = '#FFFFFF';

/* 流れ星パラメータ */
const METEOR_SPAWN_ON_LOAD = true;   // 初回必ず1本
const METEOR_INTERVAL_MS   = 12000;  // 何msごとに判定
const METEOR_SPAWN_PROB    = 0.25;   // そのとき出現する確率

const container = document.querySelector('.circle');
const canvas    = document.getElementById('sky');
const ctx       = canvas.getContext('2d');

let cssW = 0, cssH = 0;
let dpr  = window.devicePixelRatio || 1;

let starNorms = [];
let starLayer = null;

const meteors = [];

/* ===== レイアウト ===== */
function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  cssW = rect.width;
  cssH = rect.height;
  dpr  = window.devicePixelRatio || 1;

  canvas.width  = Math.max(1, Math.floor(cssW * dpr));
  canvas.height = Math.max(1, Math.floor(cssH * dpr));
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  if (starNorms.length) buildStarLayer();
}

window.addEventListener('resize', resizeCanvas, { passive: true });

/* ===== 起動 ===== */
async function start() {
  resizeCanvas();
  const img = await loadImage(SOURCE_IMAGE);
  await extractStarsFromImage(img);
  buildStarLayer();

  if (METEOR_SPAWN_ON_LOAD) spawnMeteor();

  setInterval(() => {
    if (Math.random() < METEOR_SPAWN_PROB) spawnMeteor();
  }, METEOR_INTERVAL_MS);

  requestAnimationFrame(loop);
}

/* 画像から星抽出 */
async function extractStarsFromImage(img) {
  const off = document.createElement('canvas');
  off.width  = IMG_SIZE;
  off.height = IMG_SIZE;
  const ox = off.getContext('2d');
  ox.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);

  const cx = IMG_SIZE / 2;
  const cy = IMG_SIZE / 2;
  const R  = IMG_SIZE / 2;

  const src  = ox.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
  const mask = new Uint8Array(IMG_SIZE * IMG_SIZE);
  const visited = new Uint8Array(mask.length);

  for (let y = 0; y < IMG_SIZE; y += STEP) {
    const dy  = y - cy;
    const dy2 = dy * dy;
    for (let x = 0; x < IMG_SIZE; x += STEP) {
      const dx = x - cx;
      if (dx * dx + dy2 > R * R) continue;
      const i = (y * IMG_SIZE + x) * 4;
      const r = src.data[i];
      const g = src.data[i + 1];
      const b = src.data[i + 2];
      if (r >= THRESH && g >= THRESH && b >= THRESH) {
        mask[y * IMG_SIZE + x] = 1;
      }
    }
  }

  const qx = [], qy = [];
  const stars = [];

  for (let y0 = 0; y0 < IMG_SIZE; y0 += STEP) {
    for (let x0 = 0; x0 < IMG_SIZE; x0 += STEP) {
      const idx0 = y0 * IMG_SIZE + x0;
      if (!mask[idx0] || visited[idx0]) continue;

      let sumX = 0, sumY = 0, count = 0;
      let head = 0, tail = 0;
      qx[tail] = x0; qy[tail] = y0; tail++;
      visited[idx0] = 1;

      while (head < tail) {
        const x = qx[head];
        const y = qy[head];
        head++;
        const idx = y * IMG_SIZE + x;

        sumX += x;
        sumY += y;
        count++;

        neigh(x + STEP, y);
        neigh(x - STEP, y);
        neigh(x, y + STEP);
        neigh(x, y - STEP);

        function neigh(nx, ny) {
          if (nx < 0 || ny < 0 || nx >= IMG_SIZE || ny >= IMG_SIZE) return;
          const nidx = ny * IMG_SIZE + nx;
          if (!mask[nidx] || visited[nidx]) return;
          visited[nidx] = 1;
          qx[tail] = nx; qy[tail] = ny; tail++;
        }
      }

      if (count >= MIN_BLOB && count <= MAX_BLOB) {
        const gx = sumX / count;
        const gy = sumY / count;
        const dx = gx - cx;
        const dy = gy - cy;
        if (dx * dx + dy * dy <= (R - 2) * (R - 2)) {
          stars.push({ x: gx / IMG_SIZE, y: gy / IMG_SIZE, w: count });
        }
      }
    }
  }

  const wMin = Math.min(...stars.map(s => s.w));
  const wMax = Math.max(...stars.map(s => s.w));
  const span = Math.max(1, wMax - wMin);

  starNorms = stars.map(s => ({
    x: s.x,
    y: s.y,
    t: (s.w - wMin) / span
  }));

  console.log(`Detected stars: ${starNorms.length}`);
}

/* 静止星を描く */
function buildStarLayer() {
  if (!starNorms.length || !cssW || !cssH) return;

  const w = cssW;
  const h = cssH;
  const size = Math.min(w, h);
  const offX = (w - size) / 2;
  const offY = (h - size) / 2;

  starLayer = document.createElement('canvas');
  starLayer.width  = w;
  starLayer.height = h;
  const ox = starLayer.getContext('2d');

  ox.fillStyle = '#000';
  ox.fillRect(0, 0, w, h);

  const pxMin = 6 * (size / IMG_SIZE);
  const pxMax = 14 * (size / IMG_SIZE);

  ox.fillStyle    = STAR_COLOR;
  ox.textAlign    = 'center';
  ox.textBaseline = 'middle';

  for (const s of starNorms) {
    const fs = pxMin + (pxMax - pxMin) * Math.pow(s.t, 0.65);
    ox.font = `${fs}px serif`;
    ox.fillText(
      STAR_CHAR,
      offX + s.x * size,
      offY + s.y * size
    );
  }
}

/* 流れ星 */
function spawnMeteor() {
  if (!cssW || !cssH) return;

  const w = cssW;
  const h = cssH;
  const size = Math.min(w, h);

  const angle = Math.random() * Math.PI * 2;
  const len   = (0.3 + Math.random() * 0.4) * size;
  const speed = len / (0.7 + Math.random() * 0.6);
  const life  = len / speed;

  const x0 = Math.random() * w;
  const y0 = Math.random() * h;

  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;

  meteors.push({
    x: x0,
    y: y0,
    vx,
    vy,
    life,
    age: 0
  });
}

function updateMeteors(dt) {
  for (let i = meteors.length - 1; i >= 0; i--) {
    const m = meteors[i];
    m.age += dt;
    m.x   += m.vx * dt;
    m.y   += m.vy * dt;

    if (m.age >= m.life ||
        m.x < -50 || m.y < -50 ||
        m.x > cssW + 50 || m.y > cssH + 50) {
      meteors.splice(i, 1);
    }
  }
}

function drawFrame() {
  if (!cssW || !cssH) return;
  ctx.clearRect(0, 0, cssW, cssH);

  if (starLayer) ctx.drawImage(starLayer, 0, 0, cssW, cssH);

  if (!meteors.length) return;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';

  for (const m of meteors) {
    const alpha = Math.max(0, 1 - m.age / m.life);
    ctx.globalAlpha = alpha;

    ctx.strokeStyle = '#7F7F7F';
    ctx.lineWidth = 1.2;

    ctx.beginPath();
    ctx.moveTo(m.x - m.vx * 0.07, m.y - m.vy * 0.07);
    ctx.lineTo(m.x, m.y);
    ctx.stroke();
  }

  ctx.restore();
}

/* ループ */
let lastTime = null;
function loop(timestamp) {
  if (lastTime == null) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  updateMeteors(dt);
  drawFrame();

  requestAnimationFrame(loop);
}

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload  = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}

start().catch(err => console.error('star build error:', err));
</script>
</body>
</html>